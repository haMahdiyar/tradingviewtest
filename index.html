<!DOCTYPE html>
<html lang="fa">
<head>
  <meta charset="UTF-8">
  <title>ابزارهای تحلیل تکنیکال پیشرفته – با آیکون</title>
  <!-- افزودن فونت آیکون Font Awesome از طریق CDN -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-..." crossorigin="anonymous" referrerpolicy="no-referrer" />
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body, html {
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }
    #toolbar {
      background-color: #f0f0f0;
      padding: 5px;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
    }
    .button {
      padding: 5px 10px;
      margin: 5px;
      cursor: pointer;
      border: 1px solid #ccc;
      background-color: #fff;
      font-size: 18px;
      line-height: 1;
    }
    .button.active {
      background-color: #ddd;
    }
    /* کانتینر کانواس: تمام فضای باقیمانده بعد از نوار ابزار */
    #canvasContainer {
      position: relative;
      width: 100%;
      height: calc(100% - 50px); /* فرض می‌کنیم نوار ابزار حدود 50px ارتفاع دارد */
    }
    #myCanvas {
      display: block;
    }
  </style>
</head>
<body>
  <!-- نوار ابزار با آیکون‌ها -->
<div id="toolbar">
    <button class="button" id="lineTool" title="خط روند">
      <i class="fas fa-minus"></i>
    </button>
    <!-- برای مستطیل از آیکون "far fa-square" (توخالی) استفاده می‌کنیم -->
    <button class="button" id="rectTool" title="مستطیل">
      <i class="far fa-square"></i>
    </button>
    <button class="button" id="circleTool" title="دایره">
      <i class="far fa-circle"></i>
    </button>
    <!-- برای فیبوناتچی، یک آیکون سفارشی SVG قرار می‌دهیم -->
    <button class="button" id="fibTool" title="فیبوناتچی">
        <svg width="16" height="16" viewBox="0 0 16 16" style="vertical-align: middle;">
          <!-- حذف شده: <rect x="1" y="1" width="14" height="14" stroke="currentColor" fill="none" stroke-width="2"/> -->
          <!-- رسم خطوط افقی برای نمایش سطوح فیبوناتچی -->
          <line x1="0" y1="4" x2="16" y2="4" stroke="currentColor" stroke-width="1"/>
          <line x1="0" y1="8" x2="16" y2="8" stroke="currentColor" stroke-width="1"/>
          <line x1="0" y1="12" x2="16" y2="12" stroke="currentColor" stroke-width="1"/>
        </svg>
      </button>
      
    <button class="button" id="pointTool" title="نقطه">
      <i class="fas fa-circle" style="font-size:0.8em;"></i>
    </button>
    <button class="button" id="textTool" title="متن">
      <i class="fas fa-font"></i>
    </button>
    <button class="button" id="selectTool" title="انتخاب/جابجایی/تغییر اندازه">
      <i class="fas fa-mouse-pointer"></i>
    </button>
    <button class="button" id="resetTool" title="ریست صفحه">
      <i class="fas fa-undo"></i>
    </button>
  </div>
  
  
  <!-- کانتینر کانواس -->
  <div id="canvasContainer">
    <canvas id="myCanvas"></canvas>
  </div>

  <script>
    // --------------------- کد اصلی (همان کدی که در نسخه‌های قبلی ارائه شده بود) ---------------------
    const canvas = document.getElementById('myCanvas');
    const ctx = canvas.getContext('2d');
    const toolbar = document.getElementById('toolbar');

    // متغیرهای عمومی
    let drawing = false;           // برای ابزارهای کشیدنی
    let startX, startY;            // مختصات شروع کشیدن برای رسم اشکال
    let currentTool = 'line';      // ابزار پیش‌فرض
    let shapes = [];               // آرایه اشیاء ذخیره‌شده
    let selectedShapeIndex = null; // اندیس شی انتخاب‌شده (در حالت select)

    // متغیرهای مربوط به جابجایی
    let dragging = false;
    let dragStartX, dragStartY;
    let shapeOriginal = null;      // موقعیت اولیه‌ی شی انتخاب‌شده

    // متغیرهای مربوط به تغییر اندازه (resizing)
    let resizing = false;
    let resizingHandle = null;     // نوع handle انتخاب‌شده

    // دکمه‌های نوار ابزار
    const buttons = {
      line: document.getElementById('lineTool'),
      rect: document.getElementById('rectTool'),
      circle: document.getElementById('circleTool'),
      fib: document.getElementById('fibTool'),
      point: document.getElementById('pointTool'),
      text: document.getElementById('textTool'),
      select: document.getElementById('selectTool'),
      reset: document.getElementById('resetTool')
    };

    // تابع clamp برای محدود کردن مقادیر به بازه مشخص
    function clamp(value, min, max) {
      return Math.max(min, Math.min(value, max));
    }

    // تابع تنظیم اندازه کانواس (ریسپانسیو)
    function updateCanvasSize() {
      const container = document.getElementById('canvasContainer');
      container.style.height = `calc(100% - ${toolbar.offsetHeight}px)`;
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;
      redrawShapes();
    }
    window.addEventListener('resize', updateCanvasSize);

    // تغییر ابزار و نمایش دکمه فعال
    function setTool(tool) {
      currentTool = tool;
      // در تغییر ابزار، هرگونه حالت انتخاب یا تغییر اندازه پاک شود.
      selectedShapeIndex = null;
      dragging = false;
      resizing = false;
      resizingHandle = null;
      for (let key in buttons) {
        if (key === tool) {
          buttons[key].classList.add('active');
        } else {
          buttons[key].classList.remove('active');
        }
      }
      canvas.style.cursor = (tool === 'select') ? 'pointer' : 'crosshair';
      redrawShapes();
    }
    
    // تنظیم رویدادهای دکمه‌ها
    buttons.line.addEventListener('click', () => setTool('line'));
    buttons.rect.addEventListener('click', () => setTool('rect'));
    buttons.circle.addEventListener('click', () => setTool('circle'));
    buttons.fib.addEventListener('click', () => setTool('fib'));
    buttons.point.addEventListener('click', () => setTool('point'));
    buttons.text.addEventListener('click', () => setTool('text'));
    buttons.select.addEventListener('click', () => setTool('select'));
    buttons.reset.addEventListener('click', resetCanvas);
    
    // بازیابی اشیاء ذخیره‌شده از LocalStorage
    window.onload = function() {
      updateCanvasSize();
      const savedShapes = localStorage.getItem('shapes');
      if (savedShapes) {
        shapes = JSON.parse(savedShapes);
        redrawShapes();
      }
    };

    // تابع رسم مجدد اشیاء روی کانواس
    function redrawShapes() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      shapes.forEach((shape, index) => {
        // برای اشیاء متنی، اگر bounding box تعریف نشده باشد، آن را محاسبه می‌کنیم.
        if (shape.type === 'text') {
          if (shape.startX === undefined || shape.startY === undefined || shape.width === undefined || shape.height === undefined) {
            ctx.font = shape.font || "16px Arial";
            const textWidth = ctx.measureText(shape.text).width;
            const textHeight = 16;
            shape.startX = shape.x;
            shape.startY = shape.y - textHeight;
            shape.width = textWidth;
            shape.height = textHeight;
          }
        }
        ctx.beginPath();
        switch(shape.type) {
          case 'line':
            ctx.moveTo(shape.startX, shape.startY);
            ctx.lineTo(shape.endX, shape.endY);
            ctx.strokeStyle = shape.color || '#000';
            ctx.lineWidth = shape.width || 2;
            ctx.stroke();
            break;
          case 'rect':
            ctx.rect(shape.startX, shape.startY, shape.width, shape.height);
            ctx.strokeStyle = shape.color || '#000';
            ctx.lineWidth = shape.lineWidth || 2;
            ctx.stroke();
            break;
          case 'circle':
            ctx.arc(shape.startX, shape.startY, shape.radius, 0, 2 * Math.PI);
            ctx.strokeStyle = shape.color || '#000';
            ctx.lineWidth = shape.lineWidth || 2;
            ctx.stroke();
            break;
          case 'fib':
            drawFibonacciRetracement(shape.startX, shape.startY, shape.endX, shape.endY);
            break;
          case 'point':
            ctx.arc(shape.x, shape.y, 3, 0, 2 * Math.PI);
            ctx.fillStyle = shape.color || 'red';
            ctx.fill();
            break;
          case 'text':
            ctx.font = shape.font || "16px Arial";
            ctx.fillStyle = shape.color || 'black';
            ctx.fillText(shape.text, shape.x, shape.y);
            break;
        }
        // اگر شی انتخاب شده باشد، آن را هایلایت و نقاط تغییر اندازه (handle) رسم می‌کنیم
        if (index === selectedShapeIndex) {
          highlightShape(shape);
          drawResizeHandles(shape);
        }
      });
    }

    // تابع رسم کادر مشخص‌کننده برای شی انتخاب‌شده
    function highlightShape(shape) {
      ctx.save();
      ctx.setLineDash([5, 3]);
      ctx.strokeStyle = 'red';
      ctx.lineWidth = 2;
      if (shape.type === 'line' || shape.type === 'fib') {
        ctx.beginPath();
        ctx.moveTo(shape.startX, shape.startY);
        ctx.lineTo(shape.endX, shape.endY);
        ctx.stroke();
      } else if (shape.type === 'rect' || shape.type === 'text') {
        ctx.strokeRect(shape.startX, shape.startY, shape.width, shape.height);
      } else if (shape.type === 'circle') {
        ctx.beginPath();
        ctx.arc(shape.startX, shape.startY, shape.radius, 0, 2 * Math.PI);
        ctx.stroke();
      } else if (shape.type === 'point') {
        ctx.beginPath();
        ctx.arc(shape.x, shape.y, 5, 0, 2 * Math.PI);
        ctx.stroke();
      }
      ctx.restore();
    }

    // تابع گرفتن نقاط handle برای تغییر اندازه
    function getResizeHandles(shape) {
      const handles = [];
      const size = 8;
      if (shape.type === 'rect' || shape.type === 'text') {
        const x0 = Math.min(shape.startX, shape.startX + shape.width);
        const x1 = Math.max(shape.startX, shape.startX + shape.width);
        const y0 = Math.min(shape.startY, shape.startY + shape.height);
        const y1 = Math.max(shape.startY, shape.startY + shape.height);
        handles.push({ x: x0, y: y0, type: 'tl' });
        handles.push({ x: x1, y: y0, type: 'tr' });
        handles.push({ x: x0, y: y1, type: 'bl' });
        handles.push({ x: x1, y: y1, type: 'br' });
      } else if (shape.type === 'circle') {
        handles.push({ x: shape.startX + shape.radius, y: shape.startY, type: 'r' });
      } else if (shape.type === 'line' || shape.type === 'fib') {
        handles.push({ x: shape.startX, y: shape.startY, type: 'start' });
        handles.push({ x: shape.endX, y: shape.endY, type: 'end' });
      }
      return handles;
    }

    // تابع رسم نقاط handle روی شی انتخاب‌شده
    function drawResizeHandles(shape) {
      const handles = getResizeHandles(shape);
      handles.forEach(handle => {
        ctx.save();
        ctx.fillStyle = 'white';
        ctx.strokeStyle = 'blue';
        ctx.lineWidth = 1;
        const size = 8;
        ctx.fillRect(handle.x - size/2, handle.y - size/2, size, size);
        ctx.strokeRect(handle.x - size/2, handle.y - size/2, size, size);
        ctx.restore();
      });
    }

    // تابع رسم فیبوناتچی به‌صورت خطوط افقی بین x1 و x2
    function drawFibonacciRetracement(x1, y1, x2, y2) {
      const xMin = Math.min(x1, x2);
      const xMax = Math.max(x1, x2);
      const yMin = Math.min(y1, y2);
      const yMax = Math.max(y1, y2);
      const fibLevels = [
        { level: 0, label: '0%' },
        { level: 0.236, label: '23.6%' },
        { level: 0.382, label: '38.2%' },
        { level: 0.5, label: '50%' },
        { level: 0.618, label: '61.8%' },
        { level: 0.786, label: '78.6%' },
        { level: 1, label: '100%' }
      ];
      fibLevels.forEach(item => {
        const y = yMin + (yMax - yMin) * item.level;
        ctx.beginPath();
        ctx.moveTo(xMin, y);
        ctx.lineTo(xMax, y);
        ctx.strokeStyle = 'blue';
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.font = "12px Arial";
        ctx.fillStyle = "blue";
        ctx.fillText(item.label, xMin + 5, y - 2);
      });
    }

    // تابع بررسی برخورد کلیک با شی (برای همه اشکال)
    function isPointOnShape(shape, x, y) {
      if (shape.type === 'line' || shape.type === 'fib') {
        const threshold = 8;
        const { startX, startY, endX, endY } = shape;
        const A = y - startY;
        const B = x - startX;
        const C = endY - startY;
        const D = endX - startX;
        const dot = A * C + B * D;
        const len_sq = C * C + D * D;
        let param = (len_sq !== 0) ? dot / len_sq : -1;
        let xx, yy;
        if (param < 0) { xx = startX; yy = startY; }
        else if (param > 1) { xx = endX; yy = endY; }
        else { xx = startX + param * D; yy = startY + param * C; }
        const dx = x - xx, dy = y - yy;
        return Math.hypot(dx, dy) <= threshold;
      } else if (shape.type === 'rect' || shape.type === 'text') {
        const x0 = Math.min(shape.startX, shape.startX + shape.width);
        const x1 = Math.max(shape.startX, shape.startX + shape.width);
        const y0 = Math.min(shape.startY, shape.startY + shape.height);
        const y1 = Math.max(shape.startY, shape.startY + shape.height);
        return (x >= x0 && x <= x1 && y >= y0 && y <= y1);
      } else if (shape.type === 'circle') {
        const dx = x - shape.startX;
        const dy = y - shape.startY;
        return Math.hypot(dx, dy) <= shape.radius;
      } else if (shape.type === 'point') {
        const dx = x - shape.x;
        const dy = y - shape.y;
        return Math.hypot(dx, dy) <= 5;
      }
      return false;
    }

    // بررسی نزدیکی کلیک به یک handle (برای تغییر اندازه)
    function getHandleAtPoint(shape, x, y) {
      const handles = getResizeHandles(shape);
      const handleThreshold = 8;
      for (let handle of handles) {
        if (Math.hypot(x - handle.x, y - handle.y) <= handleThreshold) {
          return handle;
        }
      }
      return null;
    }

    // تابع تغییر اندازه شی بر اساس handle انتخاب‌شده
    function resizeShape(shape, handleType, dx, dy) {
      if (shape.type === 'rect' || shape.type === 'text') {
        if (handleType === 'br') {
          shape.width = Math.max(10, shapeOriginal.width + dx);
          shape.height = Math.max(10, shapeOriginal.height + dy);
        } else if (handleType === 'tl') {
          shape.startX = shapeOriginal.startX + dx;
          shape.startY = shapeOriginal.startY + dy;
          shape.width = Math.max(10, shapeOriginal.width - dx);
          shape.height = Math.max(10, shapeOriginal.height - dy);
        } else if (handleType === 'tr') {
          shape.startY = shapeOriginal.startY + dy;
          shape.width = Math.max(10, shapeOriginal.width + dx);
          shape.height = Math.max(10, shapeOriginal.height - dy);
        } else if (handleType === 'bl') {
          shape.startX = shapeOriginal.startX + dx;
          shape.width = Math.max(10, shapeOriginal.width - dx);
          shape.height = Math.max(10, shapeOriginal.height + dy);
        }
      } else if (shape.type === 'circle') {
        if (handleType === 'r') {
          let newRadius = Math.abs(shapeOriginal.radius + dx);
          shape.radius = Math.max(5, newRadius);
        }
      } else if (shape.type === 'line' || shape.type === 'fib') {
        if (handleType === 'start') {
          shape.startX = shapeOriginal.startX + dx;
          shape.startY = shapeOriginal.startY + dy;
        } else if (handleType === 'end') {
          shape.endX = shapeOriginal.endX + dx;
          shape.endY = shapeOriginal.endY + dy;
        }
      }
    }

    // تابع جابجایی (حرکت کامل) شی به صورت محدود به محدوده کانواس
    function moveShapeWithClamp(shape, dx, dy) {
      if (shape.type === 'rect' || shape.type === 'text') {
        let newX = clamp(shapeOriginal.startX + dx, 0, canvas.width - shape.width);
        let newY = clamp(shapeOriginal.startY + dy, 0, canvas.height - shape.height);
        shape.startX = newX;
        shape.startY = newY;
        if (shape.type === 'text') {
          shape.x = newX;
          shape.y = newY + shape.height;
        }
      } else if (shape.type === 'circle') {
        let newX = clamp(shapeOriginal.startX + dx, shape.radius, canvas.width - shape.radius);
        let newY = clamp(shapeOriginal.startY + dy, shape.radius, canvas.height - shape.radius);
        shape.startX = newX;
        shape.startY = newY;
      } else if (shape.type === 'line' || shape.type === 'fib') {
        shape.startX = clamp(shapeOriginal.startX + dx, 0, canvas.width);
        shape.startY = clamp(shapeOriginal.startY + dy, 0, canvas.height);
        shape.endX   = clamp(shapeOriginal.endX + dx, 0, canvas.width);
        shape.endY   = clamp(shapeOriginal.endY + dy, 0, canvas.height);
      } else if (shape.type === 'point') {
        shape.x = clamp(shapeOriginal.x + dx, 0, canvas.width);
        shape.y = clamp(shapeOriginal.y + dy, 0, canvas.height);
      }
    }

    // -----------------------
    // رویدادهای مربوط به ابزارهای کشیدنی (برای خط، مستطیل، دایره، فیب)
    canvas.addEventListener('mousedown', (e) => {
      const x = e.offsetX, y = e.offsetY;
      if (currentTool === 'line' || currentTool === 'rect' || currentTool === 'circle' || currentTool === 'fib') {
        drawing = true;
        startX = x; startY = y;
      } else if (currentTool === 'select') {
        // ابتدا بررسی کلیک روی handle (برای تغییر اندازه)
        if (selectedShapeIndex !== null) {
          const selShape = shapes[selectedShapeIndex];
          const handle = getHandleAtPoint(selShape, x, y);
          if (handle) {
            resizing = true;
            resizingHandle = handle.type;
            dragStartX = x; dragStartY = y;
            shapeOriginal = JSON.parse(JSON.stringify(selShape));
            return;
          }
        }
        // در غیر این صورت سعی در انتخاب شی داریم
        for (let i = shapes.length - 1; i >= 0; i--) {
          if (isPointOnShape(shapes[i], x, y)) {
            selectedShapeIndex = i;
            dragging = true;
            dragStartX = x;
            dragStartY = y;
            shapeOriginal = JSON.parse(JSON.stringify(shapes[i]));
            redrawShapes();
            return;
          }
        }
        selectedShapeIndex = null;
        redrawShapes();
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      const currentX = e.offsetX, currentY = e.offsetY;
      if (drawing) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        redrawShapes();
        ctx.beginPath();
        if (currentTool === 'line') {
          ctx.moveTo(startX, startY);
          ctx.lineTo(currentX, currentY);
          ctx.strokeStyle = 'gray';
          ctx.lineWidth = 1;
          ctx.stroke();
        } else if (currentTool === 'rect') {
          ctx.rect(startX, startY, currentX - startX, currentY - startY);
          ctx.strokeStyle = 'gray';
          ctx.lineWidth = 1;
          ctx.stroke();
        } else if (currentTool === 'circle') {
          const radius = Math.hypot(currentX - startX, currentY - startY);
          ctx.arc(startX, startY, radius, 0, 2 * Math.PI);
          ctx.strokeStyle = 'gray';
          ctx.lineWidth = 1;
          ctx.stroke();
        } else if (currentTool === 'fib') {
          drawFibonacciRetracement(startX, startY, currentX, currentY);
        }
      } else if (dragging && currentTool === 'select' && selectedShapeIndex !== null && !resizing) {
        const dx = currentX - dragStartX;
        const dy = currentY - dragStartY;
        let shape = shapes[selectedShapeIndex];
        moveShapeWithClamp(shape, dx, dy);
        redrawShapes();
      } else if (resizing && currentTool === 'select' && selectedShapeIndex !== null) {
        const dx = currentX - dragStartX;
        const dy = currentY - dragStartY;
        let shape = shapes[selectedShapeIndex];
        resizeShape(shape, resizingHandle, dx, dy);
        redrawShapes();
      }
    });

    canvas.addEventListener('mouseup', (e) => {
      if (drawing) {
        drawing = false;
        const endX = e.offsetX, endY = e.offsetY;
        let newShape = {};
        if (currentTool === 'line') {
          newShape = { type: 'line', startX, startY, endX, endY, color: '#000', width: 2 };
        } else if (currentTool === 'rect') {
          newShape = { type: 'rect', startX, startY, width: endX - startX, height: endY - startY, color: '#000', lineWidth: 2 };
        } else if (currentTool === 'circle') {
          const radius = Math.hypot(endX - startX, endY - startY);
          newShape = { type: 'circle', startX, startY, radius, color: '#000', lineWidth: 2 };
        } else if (currentTool === 'fib') {
          newShape = { type: 'fib', startX, startY, endX, endY };
        }
        shapes.push(newShape);
        localStorage.setItem('shapes', JSON.stringify(shapes));
        redrawShapes();
      }
      if (dragging) {
        dragging = false;
        localStorage.setItem('shapes', JSON.stringify(shapes));
      }
      if (resizing) {
        resizing = false;
        resizingHandle = null;
        localStorage.setItem('shapes', JSON.stringify(shapes));
      }
    });

    // رویداد کلیک برای ابزارهای غیرکشیدنی (نقطه و متن) و حالت select
    canvas.addEventListener('click', (e) => {
      const x = e.offsetX, y = e.offsetY;
      if (currentTool === 'point') {
        const newShape = { type: 'point', x, y, color: 'red' };
        shapes.push(newShape);
        localStorage.setItem('shapes', JSON.stringify(shapes));
        redrawShapes();
      } else if (currentTool === 'text') {
        const userText = prompt("متن مورد نظر را وارد کنید:");
        if (userText) {
          const newShape = { type: 'text', x, y, text: userText, color: 'black', font: "16px Arial", startX: x, startY: y - 16, width: 100, height: 16 };
          shapes.push(newShape);
          localStorage.setItem('shapes', JSON.stringify(shapes));
          redrawShapes();
        }
      } else if (currentTool === 'select') {
        if (!dragging && !resizing) {
          let found = false;
          for (let i = shapes.length - 1; i >= 0; i--) {
            if (isPointOnShape(shapes[i], x, y)) {
              selectedShapeIndex = i;
              found = true;
              break;
            }
          }
          if (!found) {
            selectedShapeIndex = null;
          }
          redrawShapes();
        }
      }
    });

    // امکان ویرایش متن با دوبار کلیک (در حالت select)
    canvas.addEventListener('dblclick', (e) => {
      const x = e.offsetX, y = e.offsetY;
      if (currentTool === 'select' && selectedShapeIndex !== null) {
        let shape = shapes[selectedShapeIndex];
        if (shape.type === 'text') {
          const newText = prompt("متن جدید را وارد کنید:", shape.text);
          if (newText !== null) {
            shape.text = newText;
            ctx.font = shape.font || "16px Arial";
            const textWidth = ctx.measureText(newText).width;
            shape.width = textWidth;
            shape.height = 16;
            localStorage.setItem('shapes', JSON.stringify(shapes));
            redrawShapes();
          }
        }
      }
    });

    // رویداد کلید برای حذف شی انتخاب‌شده (Delete یا Backspace)
    document.addEventListener('keydown', (e) => {
      if (currentTool === 'select' && selectedShapeIndex !== null) {
        if (e.key === 'Delete' || e.key === 'Backspace') {
          shapes.splice(selectedShapeIndex, 1);
          selectedShapeIndex = null;
          localStorage.setItem('shapes', JSON.stringify(shapes));
          redrawShapes();
        }
      }
    });

    // تابع ریست کل صفحه
    function resetCanvas() {
      if (confirm("آیا مطمئن هستید که می‌خواهید کل صفحه را پاک کنید؟")) {
        shapes = [];
        selectedShapeIndex = null;
        localStorage.removeItem('shapes');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
    }
  </script>
</body>
</html>
